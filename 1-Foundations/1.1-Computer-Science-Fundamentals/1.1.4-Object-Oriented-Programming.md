# 1.1.4 Object-Oriented Programming

Classes, inheritance, polymorphism, encapsulation—organizing code into reusable components.

---

## What Is Object-Oriented Programming?

**Object-Oriented Programming (OOP)** is a programming paradigm that organizes code around **objects**—entities that combine data (attributes) and behavior (methods). OOP models real-world concepts and relationships in code.

---

## Why OOP Matters

| Benefit | Explanation |
|---------|-------------|
| **Modularity** | Code is organized into self-contained units |
| **Reusability** | Classes can be reused across projects |
| **Maintainability** | Changes are localized to specific classes |
| **Abstraction** | Complex systems are easier to understand |
| **Scalability** | Large codebases become manageable |

---

## The Four Pillars of OOP

### 1. Encapsulation

**Encapsulation** bundles data and the methods that operate on that data within a single unit (class), restricting direct access to some components.

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner          # Public attribute
        self._balance = balance     # Protected (convention)
        self.__pin = "1234"         # Private (name mangling)

    def deposit(self, amount):
        """Public method to safely modify balance"""
        if amount > 0:
            self._balance += amount
            return True
        return False

    def withdraw(self, amount):
        """Controlled access to balance"""
        if 0 < amount <= self._balance:
            self._balance -= amount
            return True
        return False

    def get_balance(self):
        """Getter - controlled read access"""
        return self._balance

    def __verify_pin(self, pin):
        """Private method"""
        return pin == self.__pin


# Usage
account = BankAccount("Alice", 1000)
account.deposit(500)           # OK - using public method
print(account.get_balance())   # 1500

# Direct access discouraged
# account._balance = 1000000   # Works but violates encapsulation
# account.__pin                # AttributeError (name mangled)
```

**Python Access Modifiers (by convention):**
- `public`: No underscore - accessible everywhere
- `_protected`: Single underscore - internal use, subclasses
- `__private`: Double underscore - name mangled, class-only

**Benefits:**
- Protects object integrity
- Hides implementation details
- Provides controlled interfaces
- Reduces unintended side effects

---

### 2. Inheritance

**Inheritance** allows a class to inherit attributes and methods from another class, promoting code reuse and establishing hierarchies.

```python
class Animal:
    """Base class / Parent class / Superclass"""

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def speak(self):
        raise NotImplementedError("Subclass must implement")

    def describe(self):
        return f"{self.name} is {self.age} years old"


class Dog(Animal):
    """Derived class / Child class / Subclass"""

    def __init__(self, name, age, breed):
        super().__init__(name, age)  # Call parent constructor
        self.breed = breed

    def speak(self):
        return f"{self.name} says Woof!"

    def fetch(self):
        return f"{self.name} fetches the ball"


class Cat(Animal):
    def __init__(self, name, age, indoor=True):
        super().__init__(name, age)
        self.indoor = indoor

    def speak(self):
        return f"{self.name} says Meow!"

    def scratch(self):
        return f"{self.name} scratches the furniture"


# Usage
dog = Dog("Buddy", 3, "Golden Retriever")
cat = Cat("Whiskers", 5)

print(dog.describe())  # Inherited method: "Buddy is 3 years old"
print(dog.speak())     # Overridden method: "Buddy says Woof!"
print(dog.fetch())     # Dog-specific method

print(cat.speak())     # "Whiskers says Meow!"
```

**Types of Inheritance:**

```python
# Single Inheritance
class B(A):
    pass

# Multiple Inheritance
class C(A, B):
    pass

# Multilevel Inheritance
class C(B):  # B inherits from A
    pass

# Hierarchical Inheritance
class B(A):
    pass
class C(A):
    pass
```

**Multiple Inheritance and MRO:**

```python
class A:
    def method(self):
        return "A"

class B(A):
    def method(self):
        return "B"

class C(A):
    def method(self):
        return "C"

class D(B, C):
    pass

# Method Resolution Order (MRO)
print(D.__mro__)  # (D, B, C, A, object)

d = D()
print(d.method())  # "B" - follows MRO
```

---

### 3. Polymorphism

**Polymorphism** allows objects of different classes to be treated as objects of a common base class. The same interface can have different implementations.

```python
class Shape:
    def area(self):
        raise NotImplementedError

    def perimeter(self):
        raise NotImplementedError


class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)


class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        import math
        return math.pi * self.radius ** 2

    def perimeter(self):
        import math
        return 2 * math.pi * self.radius


class Triangle(Shape):
    def __init__(self, a, b, c):
        self.a, self.b, self.c = a, b, c

    def area(self):
        # Heron's formula
        s = (self.a + self.b + self.c) / 2
        return (s * (s-self.a) * (s-self.b) * (s-self.c)) ** 0.5

    def perimeter(self):
        return self.a + self.b + self.c


# Polymorphic behavior
def print_shape_info(shape):
    """Works with any Shape subclass"""
    print(f"Area: {shape.area():.2f}")
    print(f"Perimeter: {shape.perimeter():.2f}")

shapes = [
    Rectangle(5, 3),
    Circle(4),
    Triangle(3, 4, 5)
]

for shape in shapes:
    print_shape_info(shape)  # Same interface, different behavior
    print()
```

**Duck Typing in Python:**

```python
# "If it walks like a duck and quacks like a duck..."
class Duck:
    def speak(self):
        return "Quack!"

class Person:
    def speak(self):
        return "Hello!"

class Robot:
    def speak(self):
        return "Beep boop!"

def make_speak(entity):
    """Doesn't care about type, just that it has speak()"""
    print(entity.speak())

# All work - duck typing!
make_speak(Duck())    # Quack!
make_speak(Person())  # Hello!
make_speak(Robot())   # Beep boop!
```

---

### 4. Abstraction

**Abstraction** hides complex implementation details and exposes only necessary interfaces.

```python
from abc import ABC, abstractmethod

class Database(ABC):
    """Abstract base class - cannot be instantiated"""

    @abstractmethod
    def connect(self):
        """Must be implemented by subclasses"""
        pass

    @abstractmethod
    def execute(self, query):
        pass

    @abstractmethod
    def close(self):
        pass

    def execute_and_close(self, query):
        """Concrete method using abstract methods"""
        result = self.execute(query)
        self.close()
        return result


class PostgresDatabase(Database):
    def connect(self):
        print("Connecting to PostgreSQL...")
        # Implementation details hidden

    def execute(self, query):
        print(f"Executing: {query}")
        return "Results"

    def close(self):
        print("Closing PostgreSQL connection")


class MongoDatabase(Database):
    def connect(self):
        print("Connecting to MongoDB...")

    def execute(self, query):
        print(f"Running MongoDB query: {query}")
        return "Documents"

    def close(self):
        print("Closing MongoDB connection")


# Usage - same interface for different databases
def run_query(db: Database, query: str):
    db.connect()
    result = db.execute(query)
    db.close()
    return result

postgres = PostgresDatabase()
mongo = MongoDatabase()

run_query(postgres, "SELECT * FROM users")
run_query(mongo, "db.users.find()")
```

---

## Classes and Objects

### Class Definition

```python
class Person:
    # Class attribute - shared by all instances
    species = "Homo sapiens"

    def __init__(self, name, age):
        # Instance attributes - unique to each instance
        self.name = name
        self.age = age

    # Instance method
    def greet(self):
        return f"Hi, I'm {self.name}"

    # Class method
    @classmethod
    def create_anonymous(cls):
        return cls("Anonymous", 0)

    # Static method
    @staticmethod
    def is_adult(age):
        return age >= 18

    # String representation
    def __str__(self):
        return f"Person({self.name}, {self.age})"

    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"


# Creating objects (instances)
alice = Person("Alice", 30)
bob = Person("Bob", 25)

print(alice.greet())           # Instance method
print(Person.species)          # Class attribute
print(Person.is_adult(20))     # Static method
anon = Person.create_anonymous()  # Class method
```

### Properties (Getters/Setters)

```python
class Temperature:
    def __init__(self, celsius=0):
        self._celsius = celsius

    @property
    def celsius(self):
        """Getter for celsius"""
        return self._celsius

    @celsius.setter
    def celsius(self, value):
        """Setter with validation"""
        if value < -273.15:
            raise ValueError("Temperature below absolute zero!")
        self._celsius = value

    @property
    def fahrenheit(self):
        """Computed property"""
        return self._celsius * 9/5 + 32

    @fahrenheit.setter
    def fahrenheit(self, value):
        self._celsius = (value - 32) * 5/9


# Usage - looks like attribute access
temp = Temperature(25)
print(temp.celsius)     # 25 (getter)
print(temp.fahrenheit)  # 77.0 (computed)

temp.fahrenheit = 100   # Setter
print(temp.celsius)     # 37.78
```

---

## Magic Methods (Dunder Methods)

Special methods that enable operator overloading and other Python features.

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # String representations
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

    def __repr__(self):
        return f"Vector(x={self.x}, y={self.y})"

    # Arithmetic operators
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

    # Comparison operators
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __lt__(self, other):
        return self.magnitude() < other.magnitude()

    # Container methods
    def __len__(self):
        return 2

    def __getitem__(self, index):
        if index == 0:
            return self.x
        elif index == 1:
            return self.y
        raise IndexError

    # Callable
    def __call__(self):
        return self.magnitude()

    def magnitude(self):
        return (self.x ** 2 + self.y ** 2) ** 0.5


# Usage
v1 = Vector(3, 4)
v2 = Vector(1, 2)

print(v1 + v2)      # Vector(4, 6) - __add__
print(v1 * 2)       # Vector(6, 8) - __mul__
print(v1 == v2)     # False - __eq__
print(v1())         # 5.0 - __call__
print(v1[0])        # 3 - __getitem__
```

**Common Magic Methods:**

| Method | Purpose |
|--------|---------|
| `__init__` | Constructor |
| `__str__` | Human-readable string |
| `__repr__` | Developer string |
| `__len__` | len() support |
| `__getitem__` | Indexing [] |
| `__setitem__` | Assignment [] |
| `__iter__` | Iteration support |
| `__eq__`, `__lt__`, etc. | Comparison |
| `__add__`, `__sub__`, etc. | Arithmetic |
| `__enter__`, `__exit__` | Context managers |

---

## Composition vs Inheritance

### When to Use Inheritance (IS-A)

```python
# Dog IS-A Animal
class Animal:
    def breathe(self):
        return "Breathing"

class Dog(Animal):
    def bark(self):
        return "Woof!"
```

### When to Use Composition (HAS-A)

```python
# Car HAS-A Engine (composition is often preferred)
class Engine:
    def __init__(self, horsepower):
        self.horsepower = horsepower

    def start(self):
        return "Engine starting..."


class Car:
    def __init__(self, make, model, horsepower):
        self.make = make
        self.model = model
        self.engine = Engine(horsepower)  # Composition

    def start(self):
        return f"{self.make} {self.model}: {self.engine.start()}"


# More flexible than inheriting from Engine
car = Car("Toyota", "Camry", 200)
print(car.start())
```

**Favor composition over inheritance** - it's more flexible and avoids deep inheritance hierarchies.

---

## SOLID Principles

### S - Single Responsibility Principle

A class should have only one reason to change.

```python
# Bad - multiple responsibilities
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

    def save_to_database(self):
        # Database logic
        pass

    def send_email(self):
        # Email logic
        pass

# Good - separated responsibilities
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class UserRepository:
    def save(self, user):
        # Database logic
        pass

class EmailService:
    def send(self, user, message):
        # Email logic
        pass
```

### O - Open/Closed Principle

Open for extension, closed for modification.

```python
# Bad - must modify class to add new shapes
class AreaCalculator:
    def calculate(self, shape):
        if shape.type == "rectangle":
            return shape.width * shape.height
        elif shape.type == "circle":
            return 3.14 * shape.radius ** 2
        # Must add elif for each new shape!

# Good - extend via new classes
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def area(self):
        return 3.14 * self.radius ** 2

# New shapes just implement Shape - no modification needed
```

### L - Liskov Substitution Principle

Subtypes must be substitutable for their base types.

```python
# Bad - Square violates rectangle's contract
class Rectangle:
    def set_width(self, width):
        self.width = width

    def set_height(self, height):
        self.height = height

class Square(Rectangle):
    def set_width(self, width):
        self.width = width
        self.height = width  # Breaks expectations!

    def set_height(self, height):
        self.width = height
        self.height = height

# Good - don't use inheritance here
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side ** 2
```

### I - Interface Segregation Principle

Clients shouldn't be forced to depend on methods they don't use.

```python
# Bad - fat interface
class Worker(ABC):
    @abstractmethod
    def work(self):
        pass

    @abstractmethod
    def eat(self):
        pass

class Robot(Worker):
    def work(self):
        return "Working"

    def eat(self):
        pass  # Robots don't eat! Forced to implement.

# Good - segregated interfaces
class Workable(ABC):
    @abstractmethod
    def work(self):
        pass

class Eatable(ABC):
    @abstractmethod
    def eat(self):
        pass

class Human(Workable, Eatable):
    def work(self):
        return "Working"

    def eat(self):
        return "Eating"

class Robot(Workable):
    def work(self):
        return "Working"
```

### D - Dependency Inversion Principle

Depend on abstractions, not concretions.

```python
# Bad - high-level depends on low-level
class MySQLDatabase:
    def query(self, sql):
        pass

class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # Tightly coupled!

# Good - depend on abstraction
class Database(ABC):
    @abstractmethod
    def query(self, sql):
        pass

class MySQLDatabase(Database):
    def query(self, sql):
        pass

class PostgresDatabase(Database):
    def query(self, sql):
        pass

class UserService:
    def __init__(self, db: Database):  # Dependency injection
        self.db = db

# Can inject any database implementation
service = UserService(MySQLDatabase())
service = UserService(PostgresDatabase())
```

---

## Common Design Patterns

### Singleton

Ensure a class has only one instance.

```python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance


# Usage
s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # True
```

### Factory

Create objects without specifying exact class.

```python
class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

class AnimalFactory:
    @staticmethod
    def create(animal_type: str) -> Animal:
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        raise ValueError(f"Unknown animal: {animal_type}")


# Usage
animal = AnimalFactory.create("dog")
print(animal.speak())  # Woof!
```

### Observer

Notify multiple objects about state changes.

```python
class Subject:
    def __init__(self):
        self._observers = []
        self._state = None

    def attach(self, observer):
        self._observers.append(observer)

    def detach(self, observer):
        self._observers.remove(observer)

    def notify(self):
        for observer in self._observers:
            observer.update(self._state)

    def set_state(self, state):
        self._state = state
        self.notify()


class Observer(ABC):
    @abstractmethod
    def update(self, state):
        pass


class ConcreteObserver(Observer):
    def __init__(self, name):
        self.name = name

    def update(self, state):
        print(f"{self.name} received: {state}")


# Usage
subject = Subject()
observer1 = ConcreteObserver("Observer 1")
observer2 = ConcreteObserver("Observer 2")

subject.attach(observer1)
subject.attach(observer2)
subject.set_state("New State")
# Observer 1 received: New State
# Observer 2 received: New State
```

### Strategy

Define a family of algorithms and make them interchangeable.

```python
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

class CreditCardPayment(PaymentStrategy):
    def pay(self, amount):
        return f"Paid ${amount} with credit card"

class PayPalPayment(PaymentStrategy):
    def pay(self, amount):
        return f"Paid ${amount} with PayPal"

class CryptoPayment(PaymentStrategy):
    def pay(self, amount):
        return f"Paid ${amount} with cryptocurrency"

class ShoppingCart:
    def __init__(self):
        self.items = []
        self.payment_strategy = None

    def set_payment_strategy(self, strategy: PaymentStrategy):
        self.payment_strategy = strategy

    def checkout(self):
        total = sum(item.price for item in self.items)
        return self.payment_strategy.pay(total)


# Usage
cart = ShoppingCart()
cart.set_payment_strategy(CreditCardPayment())
cart.checkout()

cart.set_payment_strategy(PayPalPayment())
cart.checkout()
```

---

## Best Practices

### 1. Keep Classes Focused
```python
# Each class should do one thing well
class EmailValidator:
    def validate(self, email):
        return "@" in email

class PasswordHasher:
    def hash(self, password):
        import hashlib
        return hashlib.sha256(password.encode()).hexdigest()
```

### 2. Use Meaningful Names
```python
# Bad
class M:
    def p(self, d):
        pass

# Good
class MessageSender:
    def publish(self, data):
        pass
```

### 3. Prefer Composition
```python
# Instead of deep inheritance, compose objects
class Logger:
    def log(self, message):
        print(message)

class Service:
    def __init__(self, logger: Logger):
        self.logger = logger

    def do_something(self):
        self.logger.log("Doing something")
```

### 4. Program to Interfaces
```python
# Depend on abstract types, not concrete implementations
def process_payment(payment: PaymentStrategy, amount: float):
    return payment.pay(amount)
```

---

## Practice Problems

1. Design a `Library` system with `Book`, `Member`, and `Librarian` classes
2. Implement a `Shape` hierarchy with area and perimeter calculations
3. Create a `Vehicle` inheritance hierarchy (Car, Motorcycle, Truck)
4. Design an `Observer` pattern for a stock price notification system
5. Implement a `Strategy` pattern for different sorting algorithms

---

## Key Takeaways

1. **Encapsulation** protects data and provides controlled access
2. **Inheritance** enables code reuse but should be used carefully
3. **Polymorphism** allows treating different types uniformly
4. **Abstraction** hides complexity behind simple interfaces
5. **Favor composition over inheritance** for flexibility
6. **Follow SOLID principles** for maintainable code
7. **Design patterns** solve common problems elegantly
8. **Keep classes small and focused** on a single responsibility

---

*"The problem with object-oriented languages is they've got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle." — Joe Armstrong*

Use OOP wisely—it's a tool, not a requirement.

# 1.1.1 Data Structures

Arrays, linked lists, stacks, queues, trees, graphs, and hash tables—how to store and organize data efficiently.

---

## What Are Data Structures?

A **data structure** is a way of organizing, storing, and managing data so that it can be accessed and modified efficiently. Choosing the right data structure for a problem is one of the most important decisions a software engineer makes.

---

## Why Data Structures Matter

| Reason | Explanation |
|--------|-------------|
| **Performance** | The right data structure can make your code 1000x faster |
| **Memory Efficiency** | Some structures use less memory than others |
| **Code Clarity** | Using appropriate structures makes code easier to understand |
| **Scalability** | Good choices allow systems to handle millions of users |

---

## Core Data Structures

### 1. Arrays

The most fundamental data structure—a contiguous block of memory storing elements of the same type.

```python
# Static array (fixed size)
numbers = [1, 2, 3, 4, 5]

# Access by index - O(1)
first = numbers[0]  # 1

# Search - O(n)
found = 3 in numbers  # True

# Insert at end - O(1) amortized
numbers.append(6)

# Insert at beginning - O(n)
numbers.insert(0, 0)
```

**Time Complexity:**
| Operation | Average | Worst |
|-----------|---------|-------|
| Access | O(1) | O(1) |
| Search | O(n) | O(n) |
| Insert (end) | O(1) | O(n) |
| Insert (middle) | O(n) | O(n) |
| Delete | O(n) | O(n) |

**When to Use:**
- When you need fast access by index
- When the size is known or mostly fixed
- When you need to iterate through all elements

---

### 2. Linked Lists

A sequence of nodes where each node contains data and a reference to the next node.

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node

    def prepend(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def delete(self, data):
        if not self.head:
            return
        if self.head.data == data:
            self.head = self.head.next
            return
        current = self.head
        while current.next:
            if current.next.data == data:
                current.next = current.next.next
                return
            current = current.next
```

**Types of Linked Lists:**
- **Singly Linked**: Each node points to next
- **Doubly Linked**: Each node points to next and previous
- **Circular**: Last node points back to first

**Time Complexity:**
| Operation | Singly | Doubly |
|-----------|--------|--------|
| Access | O(n) | O(n) |
| Search | O(n) | O(n) |
| Insert (head) | O(1) | O(1) |
| Insert (tail) | O(n) or O(1)* | O(1) |
| Delete | O(n) | O(1)** |

*O(1) if tail pointer maintained | **O(1) if node reference given

**When to Use:**
- Frequent insertions/deletions at beginning
- Unknown size that changes frequently
- Implementing stacks and queues

---

### 3. Stacks

**LIFO** (Last In, First Out) - Think of a stack of plates.

```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        raise IndexError("Stack is empty")

    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        raise IndexError("Stack is empty")

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

# Usage
stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
print(stack.pop())  # 3
print(stack.peek()) # 2
```

**Real-World Applications:**
- Browser back button (navigation history)
- Undo functionality in editors
- Function call stack in programming
- Expression evaluation and syntax parsing
- Balanced parentheses checking

---

### 4. Queues

**FIFO** (First In, First Out) - Think of a line at a store.

```python
from collections import deque

class Queue:
    def __init__(self):
        self.items = deque()

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.items.popleft()
        raise IndexError("Queue is empty")

    def front(self):
        if not self.is_empty():
            return self.items[0]
        raise IndexError("Queue is empty")

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

# Usage
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
print(queue.dequeue())  # 1
print(queue.front())    # 2
```

**Variations:**
- **Priority Queue**: Elements dequeued by priority, not order
- **Circular Queue**: Wraps around to use space efficiently
- **Double-ended Queue (Deque)**: Insert/remove from both ends

**Real-World Applications:**
- Print job scheduling
- Task scheduling in operating systems
- BFS (Breadth-First Search) in graphs
- Message queues in distributed systems
- Buffering (video streaming, keyboard input)

---

### 5. Hash Tables (Hash Maps)

Key-value storage with O(1) average lookup using a hash function.

```python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.buckets = [[] for _ in range(size)]

    def _hash(self, key):
        return hash(key) % self.size

    def put(self, key, value):
        index = self._hash(key)
        bucket = self.buckets[index]

        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)  # Update existing
                return
        bucket.append((key, value))  # Add new

    def get(self, key):
        index = self._hash(key)
        bucket = self.buckets[index]

        for k, v in bucket:
            if k == key:
                return v
        raise KeyError(key)

    def remove(self, key):
        index = self._hash(key)
        bucket = self.buckets[index]

        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                return
        raise KeyError(key)

# In practice, use Python's built-in dict
user = {
    "name": "Alice",
    "age": 30,
    "email": "alice@example.com"
}
print(user["name"])  # O(1) lookup
```

**Collision Handling:**
1. **Chaining**: Store collisions in a linked list at each index
2. **Open Addressing**: Find next available slot (linear probing, quadratic probing)

**Time Complexity:**
| Operation | Average | Worst |
|-----------|---------|-------|
| Insert | O(1) | O(n) |
| Search | O(1) | O(n) |
| Delete | O(1) | O(n) |

**When to Use:**
- Fast lookups by key
- Counting frequencies
- Caching/memoization
- Removing duplicates
- Implementing sets

---

### 6. Trees

Hierarchical data structure with a root node and child nodes.

#### Binary Tree
```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

# Example: Building a tree
#       1
#      / \
#     2   3
#    / \
#   4   5

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
```

#### Binary Search Tree (BST)
A binary tree where left children < parent < right children.

```python
class BST:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if not self.root:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)

    def _insert_recursive(self, node, value):
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
            else:
                self._insert_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = TreeNode(value)
            else:
                self._insert_recursive(node.right, value)

    def search(self, value):
        return self._search_recursive(self.root, value)

    def _search_recursive(self, node, value):
        if node is None or node.value == value:
            return node
        if value < node.value:
            return self._search_recursive(node.left, value)
        return self._search_recursive(node.right, value)
```

#### Tree Traversals
```python
def inorder(node):
    """Left -> Root -> Right (gives sorted order for BST)"""
    if node:
        inorder(node.left)
        print(node.value, end=' ')
        inorder(node.right)

def preorder(node):
    """Root -> Left -> Right (good for copying trees)"""
    if node:
        print(node.value, end=' ')
        preorder(node.left)
        preorder(node.right)

def postorder(node):
    """Left -> Right -> Root (good for deleting trees)"""
    if node:
        postorder(node.left)
        postorder(node.right)
        print(node.value, end=' ')

def level_order(root):
    """BFS - level by level"""
    if not root:
        return
    queue = [root]
    while queue:
        node = queue.pop(0)
        print(node.value, end=' ')
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
```

**BST Time Complexity:**
| Operation | Average | Worst (unbalanced) |
|-----------|---------|-------------------|
| Insert | O(log n) | O(n) |
| Search | O(log n) | O(n) |
| Delete | O(log n) | O(n) |

**Other Important Trees:**
- **AVL Tree**: Self-balancing BST
- **Red-Black Tree**: Self-balancing (used in many languages' map/set)
- **B-Tree**: Used in databases and file systems
- **Trie**: For string/prefix operations
- **Heap**: Complete binary tree for priority queues

---

### 7. Heaps

A complete binary tree where each parent is smaller (min-heap) or larger (max-heap) than its children.

```python
import heapq

# Min Heap (default in Python)
min_heap = []
heapq.heappush(min_heap, 3)
heapq.heappush(min_heap, 1)
heapq.heappush(min_heap, 4)
heapq.heappush(min_heap, 1)
heapq.heappush(min_heap, 5)

print(heapq.heappop(min_heap))  # 1 (smallest)
print(heapq.heappop(min_heap))  # 1

# Max Heap (negate values)
max_heap = []
heapq.heappush(max_heap, -3)
heapq.heappush(max_heap, -1)
heapq.heappush(max_heap, -4)

print(-heapq.heappop(max_heap))  # 4 (largest)
```

**Time Complexity:**
| Operation | Time |
|-----------|------|
| Insert | O(log n) |
| Extract Min/Max | O(log n) |
| Peek Min/Max | O(1) |
| Build Heap | O(n) |

**Applications:**
- Priority queues
- Heap sort
- Finding k-th largest/smallest
- Dijkstra's algorithm
- Median maintenance

---

### 8. Graphs

A collection of vertices (nodes) connected by edges.

```python
# Adjacency List (most common)
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Adjacency Matrix
#     A  B  C  D  E  F
# A [[0, 1, 1, 0, 0, 0],
# B  [1, 0, 0, 1, 1, 0],
# C  [1, 0, 0, 0, 0, 1],
# D  [0, 1, 0, 0, 0, 0],
# E  [0, 1, 0, 0, 0, 1],
# F  [0, 0, 1, 0, 1, 0]]
```

#### Graph Traversals

```python
def bfs(graph, start):
    """Breadth-First Search - explore level by level"""
    visited = set()
    queue = [start]
    visited.add(start)

    while queue:
        vertex = queue.pop(0)
        print(vertex, end=' ')

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

def dfs(graph, start, visited=None):
    """Depth-First Search - explore as deep as possible first"""
    if visited is None:
        visited = set()

    visited.add(start)
    print(start, end=' ')

    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

# BFS: A B C D E F (level by level)
# DFS: A B D E F C (deep first)
```

**Graph Types:**
- **Directed vs Undirected**: Edges have direction or not
- **Weighted vs Unweighted**: Edges have costs or not
- **Cyclic vs Acyclic**: Contains cycles or not
- **Connected vs Disconnected**: All vertices reachable or not

**Graph Representation Comparison:**
| | Adjacency List | Adjacency Matrix |
|---|----------------|------------------|
| Space | O(V + E) | O(V²) |
| Add Edge | O(1) | O(1) |
| Check Edge | O(degree) | O(1) |
| Best For | Sparse graphs | Dense graphs |

**Applications:**
- Social networks (friend connections)
- Maps and navigation
- Web page links
- Dependency resolution
- Network routing

---

### 9. Tries (Prefix Trees)

Specialized tree for storing strings, enabling fast prefix searches.

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self._find_node(word)
        return node is not None and node.is_end_of_word

    def starts_with(self, prefix):
        return self._find_node(prefix) is not None

    def _find_node(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return None
            node = node.children[char]
        return node

# Usage
trie = Trie()
trie.insert("apple")
trie.insert("app")
trie.insert("application")

print(trie.search("app"))        # True
print(trie.search("appl"))       # False
print(trie.starts_with("appl"))  # True
```

**Applications:**
- Autocomplete
- Spell checkers
- IP routing
- Word games (Scrabble, Boggle)

---

## Data Structure Selection Guide

```
Need fast access by index?
    → Array

Need fast insert/delete at ends?
    → Linked List or Deque

Need LIFO behavior?
    → Stack

Need FIFO behavior?
    → Queue

Need fast lookup by key?
    → Hash Table

Need sorted data with fast operations?
    → BST or Balanced Tree

Need to find min/max quickly?
    → Heap

Need to model relationships?
    → Graph

Need prefix searching?
    → Trie
```

---

## Comparison Chart

| Structure | Access | Search | Insert | Delete | Space |
|-----------|--------|--------|--------|--------|-------|
| Array | O(1) | O(n) | O(n) | O(n) | O(n) |
| Linked List | O(n) | O(n) | O(1)* | O(1)* | O(n) |
| Stack | O(n) | O(n) | O(1) | O(1) | O(n) |
| Queue | O(n) | O(n) | O(1) | O(1) | O(n) |
| Hash Table | N/A | O(1) | O(1) | O(1) | O(n) |
| BST | O(log n) | O(log n) | O(log n) | O(log n) | O(n) |
| Heap | O(1)** | O(n) | O(log n) | O(log n) | O(n) |

*With pointer to location | **Only for min/max

---

## Practice Problems

### Easy
1. Implement a stack using arrays
2. Implement a queue using two stacks
3. Reverse a linked list
4. Check if parentheses are balanced (stack)
5. Implement a hash set

### Medium
1. Design an LRU Cache (hash map + doubly linked list)
2. Implement a binary search tree with all operations
3. Find if a graph has a cycle
4. Serialize and deserialize a binary tree
5. Implement an autocomplete system (trie)

### Hard
1. Design a data structure that supports insert, delete, getRandom in O(1)
2. Implement a median finder with O(log n) add (two heaps)
3. Find shortest path in weighted graph (Dijkstra)
4. Word search II (trie + backtracking)

---

## Key Takeaways

1. **Arrays** are best when you need index-based access and know the size
2. **Linked Lists** excel at frequent insertions/deletions at known positions
3. **Stacks and Queues** are fundamental for many algorithms (DFS uses stack, BFS uses queue)
4. **Hash Tables** provide O(1) average lookup—use them liberally
5. **Trees** maintain hierarchy and sorted order efficiently
6. **Graphs** model relationships and connections between entities
7. **Choose based on your most frequent operation**—optimize for the common case

---

*"Bad programmers worry about the code. Good programmers worry about data structures and their relationships." — Linus Torvalds*

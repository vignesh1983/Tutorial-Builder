# 1.1.5 Functional Programming

Pure functions, immutability, higher-order functions—a different paradigm for thinking about code.

---

## What Is Functional Programming?

**Functional Programming (FP)** is a programming paradigm that treats computation as the evaluation of mathematical functions. It emphasizes:

- **Pure functions** without side effects
- **Immutable data** that doesn't change
- **Functions as first-class citizens**
- **Declarative style** (what to do, not how)

---

## Why Functional Programming Matters

| Benefit | Explanation |
|---------|-------------|
| **Predictability** | Pure functions always return the same output for the same input |
| **Testability** | No side effects means easier testing |
| **Parallelism** | Immutable data is safe for concurrent access |
| **Debugging** | No hidden state changes to track down |
| **Composability** | Small functions combine into complex operations |

---

## Core Concepts

### 1. Pure Functions

A **pure function**:
- Always returns the same output for the same input
- Has no side effects (doesn't modify external state)

```python
# Pure function
def add(a, b):
    return a + b

# Always returns 5 for (2, 3)
print(add(2, 3))  # 5
print(add(2, 3))  # 5

# Impure function - depends on external state
counter = 0

def increment():
    global counter
    counter += 1
    return counter

print(increment())  # 1
print(increment())  # 2 - different result!

# Impure function - side effect
def greet_with_print(name):
    print(f"Hello, {name}")  # Side effect: I/O
    return f"Hello, {name}"
```

**Converting Impure to Pure:**

```python
# Impure - modifies input
def add_item_impure(cart, item):
    cart.append(item)  # Mutates original!
    return cart

# Pure - returns new list
def add_item_pure(cart, item):
    return cart + [item]  # Returns new list

original = [1, 2, 3]
new_cart = add_item_pure(original, 4)
print(original)   # [1, 2, 3] - unchanged
print(new_cart)   # [1, 2, 3, 4]
```

**Benefits of Pure Functions:**
- Cacheable (memoization)
- Parallelizable
- Testable in isolation
- Easier to reason about

---

### 2. Immutability

**Immutable data** cannot be changed after creation. Instead of modifying data, you create new data.

```python
# Mutable (avoid in FP)
numbers = [1, 2, 3]
numbers.append(4)  # Modifies original
numbers[0] = 10    # Modifies original

# Immutable approach
original = (1, 2, 3)  # Tuple is immutable
new_tuple = original + (4,)  # Creates new tuple

# With lists - create new instead of mutating
def add_element(lst, element):
    return [*lst, element]  # Spread operator creates new list

original = [1, 2, 3]
result = add_element(original, 4)
print(original)  # [1, 2, 3] - unchanged
print(result)    # [1, 2, 3, 4]
```

**Immutable Updates for Nested Data:**

```python
# Original nested structure
user = {
    "name": "Alice",
    "address": {
        "city": "NYC",
        "zip": "10001"
    }
}

# Immutable update - create new dict
def update_city(user, new_city):
    return {
        **user,
        "address": {
            **user["address"],
            "city": new_city
        }
    }

new_user = update_city(user, "Boston")
print(user["address"]["city"])      # NYC - unchanged
print(new_user["address"]["city"])  # Boston
```

**Frozen Data Structures:**

```python
from dataclasses import dataclass

# Immutable class with frozen=True
@dataclass(frozen=True)
class Point:
    x: int
    y: int

p = Point(1, 2)
# p.x = 3  # Raises FrozenInstanceError!

# Create new instance instead
new_p = Point(3, p.y)
```

---

### 3. First-Class Functions

Functions can be:
- Assigned to variables
- Passed as arguments
- Returned from other functions

```python
# Assign function to variable
def greet(name):
    return f"Hello, {name}"

say_hello = greet  # Function is just a value
print(say_hello("World"))  # Hello, World

# Store functions in data structures
operations = {
    "add": lambda a, b: a + b,
    "subtract": lambda a, b: a - b,
    "multiply": lambda a, b: a * b
}

print(operations["add"](5, 3))       # 8
print(operations["multiply"](5, 3))  # 15

# Pass function as argument
def apply_operation(func, a, b):
    return func(a, b)

result = apply_operation(lambda x, y: x ** y, 2, 3)
print(result)  # 8
```

---

### 4. Higher-Order Functions

Functions that take functions as arguments or return functions.

```python
# Takes function as argument
def apply_twice(func, value):
    return func(func(value))

def double(x):
    return x * 2

print(apply_twice(double, 3))  # 12 (3 -> 6 -> 12)

# Returns function
def multiplier(factor):
    def multiply(x):
        return x * factor
    return multiply

double = multiplier(2)
triple = multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```

---

## Essential FP Functions

### Map

Apply a function to every element in a collection.

```python
# Imperative approach
numbers = [1, 2, 3, 4, 5]
squared = []
for n in numbers:
    squared.append(n ** 2)

# Functional approach with map
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # [1, 4, 9, 16, 25]

# List comprehension (Pythonic)
squared = [x ** 2 for x in numbers]

# Map with named function
def square(x):
    return x ** 2

squared = list(map(square, numbers))
```

### Filter

Select elements that match a condition.

```python
# Imperative approach
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = []
for n in numbers:
    if n % 2 == 0:
        evens.append(n)

# Functional approach with filter
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # [2, 4, 6, 8, 10]

# List comprehension
evens = [x for x in numbers if x % 2 == 0]

# Combining map and filter
# Get squares of even numbers
result = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, numbers)))
print(result)  # [4, 16, 36, 64, 100]

# List comprehension equivalent
result = [x ** 2 for x in numbers if x % 2 == 0]
```

### Reduce

Combine all elements into a single value.

```python
from functools import reduce

# Sum all numbers
numbers = [1, 2, 3, 4, 5]
total = reduce(lambda acc, x: acc + x, numbers)
print(total)  # 15

# How reduce works:
# Step 1: acc=1, x=2 -> 3
# Step 2: acc=3, x=3 -> 6
# Step 3: acc=6, x=4 -> 10
# Step 4: acc=10, x=5 -> 15

# With initial value
total = reduce(lambda acc, x: acc + x, numbers, 10)
print(total)  # 25 (starts with 10)

# Find maximum
maximum = reduce(lambda a, b: a if a > b else b, numbers)
print(maximum)  # 5

# Flatten nested lists
nested = [[1, 2], [3, 4], [5, 6]]
flattened = reduce(lambda acc, lst: acc + lst, nested, [])
print(flattened)  # [1, 2, 3, 4, 5, 6]

# Build a dictionary
pairs = [("a", 1), ("b", 2), ("c", 3)]
dictionary = reduce(lambda d, pair: {**d, pair[0]: pair[1]}, pairs, {})
print(dictionary)  # {'a': 1, 'b': 2, 'c': 3}
```

### Combining Map, Filter, Reduce

```python
from functools import reduce

# Problem: Sum of squares of even numbers
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Step by step
evens = filter(lambda x: x % 2 == 0, numbers)      # [2, 4, 6, 8, 10]
squares = map(lambda x: x ** 2, evens)             # [4, 16, 36, 64, 100]
total = reduce(lambda a, b: a + b, squares)        # 220

# Chained
result = reduce(
    lambda a, b: a + b,
    map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, numbers))
)

# Generator expression (more Pythonic)
result = sum(x ** 2 for x in numbers if x % 2 == 0)
```

---

## Function Composition

Combining simple functions to build complex operations.

```python
from functools import reduce

def compose(*functions):
    """Compose functions right to left: compose(f, g, h)(x) = f(g(h(x)))"""
    return reduce(lambda f, g: lambda x: f(g(x)), functions)

def pipe(*functions):
    """Compose functions left to right: pipe(f, g, h)(x) = h(g(f(x)))"""
    return reduce(lambda f, g: lambda x: g(f(x)), functions)

# Example functions
def add_one(x):
    return x + 1

def double(x):
    return x * 2

def square(x):
    return x ** 2

# Compose: square(double(add_one(3))) = square(double(4)) = square(8) = 64
composed = compose(square, double, add_one)
print(composed(3))  # 64

# Pipe: square(double(add_one(3))) - more readable order
piped = pipe(add_one, double, square)
print(piped(3))  # 64
```

---

## Closures

A function that remembers the environment in which it was created.

```python
def counter():
    count = 0

    def increment():
        nonlocal count
        count += 1
        return count

    return increment

# Each counter has its own state
counter1 = counter()
counter2 = counter()

print(counter1())  # 1
print(counter1())  # 2
print(counter2())  # 1 - independent state

# Practical example: Configuration
def create_multiplier(factor):
    def multiply(x):
        return x * factor
    return multiply

double = create_multiplier(2)
triple = create_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```

---

## Currying and Partial Application

### Currying

Transform a function with multiple arguments into a sequence of functions with single arguments.

```python
# Regular function
def add(a, b, c):
    return a + b + c

print(add(1, 2, 3))  # 6

# Curried version
def add_curried(a):
    def add_b(b):
        def add_c(c):
            return a + b + c
        return add_c
    return add_b

print(add_curried(1)(2)(3))  # 6

# Partial application with currying
add_one = add_curried(1)
add_one_and_two = add_one(2)
print(add_one_and_two(3))  # 6
```

### Partial Application

Fix some arguments of a function to create a new function.

```python
from functools import partial

def power(base, exponent):
    return base ** exponent

# Create specialized functions
square = partial(power, exponent=2)
cube = partial(power, exponent=3)

print(square(5))  # 25
print(cube(5))    # 125

# Practical example: Logging
def log(level, message):
    print(f"[{level}] {message}")

debug = partial(log, "DEBUG")
info = partial(log, "INFO")
error = partial(log, "ERROR")

debug("Starting process")  # [DEBUG] Starting process
error("Something failed")  # [ERROR] Something failed
```

---

## Recursion in FP

Recursion is preferred over loops in pure FP.

```python
# Iterative (imperative)
def sum_iterative(numbers):
    total = 0
    for n in numbers:
        total += n
    return total

# Recursive (functional)
def sum_recursive(numbers):
    if not numbers:
        return 0
    return numbers[0] + sum_recursive(numbers[1:])

# Tail-recursive (can be optimized)
def sum_tail_recursive(numbers, accumulator=0):
    if not numbers:
        return accumulator
    return sum_tail_recursive(numbers[1:], accumulator + numbers[0])

# Note: Python doesn't optimize tail recursion
# Use iteration or reduce for large lists
```

---

## Lazy Evaluation

Compute values only when needed.

```python
# Eager - computes all values immediately
eager_squares = [x ** 2 for x in range(1000000)]

# Lazy - computes values on demand
lazy_squares = (x ** 2 for x in range(1000000))

# Generator function - lazy
def squares_generator(n):
    for i in range(n):
        yield i ** 2

# Only computes what's needed
lazy = squares_generator(1000000)
print(next(lazy))  # 0
print(next(lazy))  # 1
print(next(lazy))  # 4

# Practical: Process large files lazily
def process_lines(filename):
    with open(filename) as f:
        for line in f:  # Lazy iteration
            yield line.strip().upper()

# itertools for lazy operations
from itertools import takewhile, dropwhile, islice

numbers = iter(range(100))
first_ten = list(islice(numbers, 10))  # Take first 10
```

---

## Declarative vs Imperative

### Imperative (How)
```python
# Step-by-step instructions
numbers = [1, 2, 3, 4, 5]
result = []
for n in numbers:
    if n % 2 == 0:
        result.append(n ** 2)
print(result)  # [4, 16]
```

### Declarative (What)
```python
# Describe what you want
numbers = [1, 2, 3, 4, 5]
result = [x ** 2 for x in numbers if x % 2 == 0]
print(result)  # [4, 16]

# Or with functions
result = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, numbers)))
```

---

## FP Patterns

### Functor Pattern

Apply a function inside a container.

```python
# List is a functor
numbers = [1, 2, 3]
result = list(map(lambda x: x * 2, numbers))  # [2, 4, 6]

# Optional/Maybe pattern
class Maybe:
    def __init__(self, value):
        self.value = value

    def map(self, func):
        if self.value is None:
            return Maybe(None)
        return Maybe(func(self.value))

    def __repr__(self):
        return f"Maybe({self.value})"

# Safe operations on potentially None values
maybe_value = Maybe(5)
result = maybe_value.map(lambda x: x * 2).map(lambda x: x + 1)
print(result)  # Maybe(11)

maybe_none = Maybe(None)
result = maybe_none.map(lambda x: x * 2)  # Safely handles None
print(result)  # Maybe(None)
```

### Monad Pattern

Chain operations that may fail or have side effects.

```python
class Result:
    """Either a success value or an error"""

    def __init__(self, value=None, error=None):
        self.value = value
        self.error = error
        self.is_ok = error is None

    @staticmethod
    def ok(value):
        return Result(value=value)

    @staticmethod
    def err(error):
        return Result(error=error)

    def map(self, func):
        if self.is_ok:
            return Result.ok(func(self.value))
        return self

    def flat_map(self, func):
        if self.is_ok:
            return func(self.value)
        return self

    def __repr__(self):
        if self.is_ok:
            return f"Ok({self.value})"
        return f"Err({self.error})"


def divide(a, b):
    if b == 0:
        return Result.err("Division by zero")
    return Result.ok(a / b)

def sqrt(x):
    if x < 0:
        return Result.err("Cannot sqrt negative")
    return Result.ok(x ** 0.5)

# Chain operations safely
result = divide(10, 2).flat_map(sqrt)
print(result)  # Ok(2.23...)

result = divide(10, 0).flat_map(sqrt)
print(result)  # Err(Division by zero)
```

---

## FP in Python: Practical Examples

### Data Pipeline

```python
from functools import reduce

# Raw data
users = [
    {"name": "Alice", "age": 30, "active": True},
    {"name": "Bob", "age": 25, "active": False},
    {"name": "Charlie", "age": 35, "active": True},
    {"name": "Diana", "age": 28, "active": True},
]

# Functional pipeline
def get_active_user_names_over_27(users):
    return list(
        map(
            lambda u: u["name"],
            filter(
                lambda u: u["active"] and u["age"] > 27,
                users
            )
        )
    )

print(get_active_user_names_over_27(users))  # ['Alice', 'Charlie', 'Diana']

# More readable with helper functions
def is_active(user):
    return user["active"]

def is_over_27(user):
    return user["age"] > 27

def get_name(user):
    return user["name"]

def both(*predicates):
    return lambda x: all(p(x) for p in predicates)

active_over_27 = filter(both(is_active, is_over_27), users)
names = map(get_name, active_over_27)
print(list(names))  # ['Alice', 'Charlie', 'Diana']
```

### Immutable State Updates

```python
from copy import deepcopy

def update_in(data, path, func):
    """Immutably update nested data at path"""
    result = deepcopy(data)
    current = result

    for key in path[:-1]:
        current = current[key]

    current[path[-1]] = func(current[path[-1]])
    return result

# Original state
state = {
    "user": {
        "profile": {
            "name": "Alice",
            "score": 100
        }
    }
}

# Update score immutably
new_state = update_in(state, ["user", "profile", "score"], lambda x: x + 10)

print(state["user"]["profile"]["score"])      # 100 (unchanged)
print(new_state["user"]["profile"]["score"])  # 110
```

### Event Handling

```python
def create_event_handler():
    handlers = []

    def subscribe(handler):
        handlers.append(handler)
        return lambda: handlers.remove(handler)  # Return unsubscribe function

    def emit(event):
        for handler in handlers:
            handler(event)

    return subscribe, emit


subscribe, emit = create_event_handler()

# Add handlers
unsubscribe = subscribe(lambda e: print(f"Handler 1: {e}"))
subscribe(lambda e: print(f"Handler 2: {e}"))

emit("Hello")
# Handler 1: Hello
# Handler 2: Hello

unsubscribe()  # Remove first handler
emit("World")
# Handler 2: World
```

---

## FP vs OOP Comparison

| Aspect | Functional | Object-Oriented |
|--------|------------|-----------------|
| State | Immutable | Mutable (encapsulated) |
| Unit | Function | Object/Class |
| Data | Separate from functions | Combined with methods |
| Composition | Function composition | Inheritance/composition |
| Side effects | Avoided | Managed/hidden |
| Testing | Very easy | Can be complex |
| Parallelism | Natural | Requires care |

### When to Use Each

**Use FP when:**
- Data transformations
- Stateless operations
- Parallel processing
- Complex data pipelines

**Use OOP when:**
- Modeling real-world entities
- State is inherently needed
- Building frameworks/libraries
- Team familiarity

**In practice:** Most codebases use both paradigms together.

---

## Practice Problems

1. Implement `map`, `filter`, and `reduce` from scratch
2. Write a pure function to deep clone an object
3. Create a function composition utility
4. Implement a Maybe monad for null-safe operations
5. Build a data transformation pipeline using only pure functions

---

## Key Takeaways

1. **Pure functions** are predictable, testable, and cacheable
2. **Immutability** prevents bugs from unexpected state changes
3. **Higher-order functions** enable powerful abstractions
4. **Map/Filter/Reduce** cover most collection operations
5. **Function composition** builds complex behavior from simple parts
6. **Lazy evaluation** improves performance for large datasets
7. **Declarative code** is often more readable than imperative
8. **FP and OOP complement each other**—use both appropriately

---

*"Object-oriented programming makes code understandable by encapsulating moving parts. Functional programming makes code understandable by minimizing moving parts." — Michael Feathers*
